## ---------------------------
##
## Script name: drugprep case study 
##
## Purpose of script: The following scripts demonstrates the use of the 'doseminer' and 
##                    'drugprepr' R-packages through the analysis of CPRD data designed
##                    to answer a research question on the risk of opioid use on fracture.
##
## Author: Dr. Belay B Yimer & Dr. David A Selby
##
## Date Last modified: 2022-11-06
##
## Email: belaybirlie.yimer@manchester.ac.uk
##
## ---------------------------
## 
## Notes: The CPRD datasets used in this script are part of a large CPRD cohort extracted 
##        to investigate the patterns of opioid prescription in UK from 2006 - 2018. In this
##        analysis onaly a subset of these data will be used. That is, individuals of â‰¥18 
##        years of age and who had a record of at least one opioid prescription between 
##        January 1, 2017, and December 31, 2017 included. Their follow end date, if not 
##        left prior to, will be July 31, 2018. 
##
## ---------------------------

## Check for packages needed to run analyses

pckgs <- c("dplyr","tidyr","doseminer","drugprepr","intervalaverage","splitstackshape", "ggplot2", "broom")
sapply(pckgs, function(x) if(!require(x,character.only=TRUE,quietly=TRUE)) {
  install.packages(x)
  require(x, character.only=TRUE)
})
rm(list=c("pckgs"))

## load packages 

library(drugprepr)
library(dplyr)
library(tidyr)
library(survival)
library(broom)

## Set folder 'Case Study' as the project root
library(here)
here::i_am("Package Example/example.R")

## Load Data sets needed for example analysis
## We need four data sets to run the analysis 
##      1. CPRD therapy data - for opioid prescription record 
##      2. product look up table - a pre-merged product lookup and common dosage look up table 
##      3. min_max data - data set generated by the researcher plausible ranges for ndd & qty
##      3. min_max data - data set generated by the researcher plausible ranges for ndd & qty
##      4. patient_extract_1 - CPRD patients table


opiate <- read.csv(here("Data/opiate_data.csv"))
product <- readstata13::read.dta13(here("Data/lookup_table_opioids.txt"))
min_max <- read.csv(here("Data/min_max_dat.csv"))
Patient_extract_1<-read.delim(here("Data/CPRD_Patient_table.txt"))

## Get the individuals with their index opioid prescription is after January 1, 2017. 

opiate <- opiate %>%
  group_by(patid) %>%
  mutate(indx_date = first(as.Date(event_date)))%>%
  filter(indx_date >= as.Date("2017-01-01"))
    

## Create a temporary followup data with column id, start_date, end_date
## The end_date is the earliest of transfer out of GP practice,
## death, or July 31, 2018

Follow_up <- opiate %>%
  dplyr::select(patid, event_date) %>%
  dplyr::group_by(patid) %>%
  dplyr::mutate(
    indx_date = first(as.Date(event_date)),
    last_fup_date = as.Date("2018-07-31") ) %>%
  dplyr::distinct(patid, .keep_all = TRUE) %>%
  dplyr::select(patid, indx_date, last_fup_date)%>%
  dplyr::left_join(Patient_extract_1,by="patid")%>%
  dplyr::select(patid, indx_date, last_fup_date,tod,deathdate)%>%
  dplyr::mutate(tod = lubridate::dmy(tod),
                deathdate = lubridate::dmy(deathdate),
                last_fup_date = min(last_fup_date,tod,deathdate,na.rm=TRUE))%>%
  dplyr::select(patid, indx_date, last_fup_date)
  
## remove not any more used objects   
rm(Patient_extract_1)

## Get the fracture data and merge it to the follow up data
## The fracture data was preprocessed using the ---- R code 
## Here, we will be using fractures identified using read codes from clinical file.

fracture_readcode <- read.csv(here("Data/fracture_clinicals_with_readcodes.csv"))
length(unique(fracture_readcode$patid)) # 856934

## convert fracture data in to a wide format

fracture_readcode$event_date <- lubridate::dmy(fracture_readcode$eventdate)
fracture_readcode_wide <- fracture_readcode %>%
  filter(event_date > lubridate::ymd("2017-01-01")) %>%
  distinct(patid, event_date, .keep_all = TRUE) %>%
  group_by(patid) %>%
  arrange(event_date) %>%
  mutate(frac_num = row_number()) %>%
  ungroup() %>%
  select(patid, event_date, frac_num) %>%
  spread(frac_num, event_date)
rm(fracture_readcode)

## Identify the first fracture that happen in the study window

Follow_up_event <- left_join(Follow_up, fracture_readcode_wide, by = "patid") %>%
  select(patid, indx_date, last_fup_date, `1`) %>%
  rename(Fracture_date = `1`) %>%
  group_by(patid) %>%
  mutate(Elligible_fracture = Fracture_date > indx_date & Fracture_date < last_fup_date)

rm(Follow_up)


## Preparing the drug exposure data

## check again i only those in the temporary follow-up table is included

opiate<-opiate[opiate$patid%in%Follow_up_event$patid, ]

## Select variables needed for drug exposure data preparation 

opiate <- select(
  opiate, patid, event_date, prodcode, qty, numdays,
  dossage_id, dosage_text, dose_duration
)

## create a pracid column to run drug prep - extract the last three digits from patid

opiate<-opiate%>%
  mutate(pracid = as.numeric(substr(patid, nchar(patid[1])-2, nchar(patid[1]))))

## cprd uses 0 if numdays is missing - replace it by NA. The same also for dose_duration

opiate$numdays[opiate$numdays==0]<-NA
opiate$dose_duration[opiate$dose_duration==0]<-NA
names(opiate)[7]<-"text"
opiate$text<-as.character(opiate$text)
  
## Now we need to define the plausible values using the min-max safety
## boundaries obtained from NICE-BNF.
product <- select(product, prodcode, drugsubstance)
min_max_extended <- product %>%
  left_join(min_max, by = "drugsubstance")
names(min_max_extended)[3:6]<-c("max_qty","min_qty","max_ndd","min_ndd")

## Decisions list for doseminer - for computing ndd  

decision_list1<- expand.grid(c("min", "mean", "max"),c("min", "mean", "max"))

## prepare the decisions for drugprepr 

#' \item{implausible_qty}{(ignore|missing|mean|median|mode|next|previous) (individual|practice|population)}
#' \item{missing_qty}{(ignore|mean|median|mode|next|previous) (individual|practice|population)}
#' \item{implausible_ndd}{(ignore|missing|mean|median|mode|next|previous) (individual|practice|population)}
#' \item{missing_ndd}{(ignore|mean|median|mode|next|previous) (individual|practice|population)}
#' \item{implausible_duration}{(ignore|missing|truncate) (6|12|24)}
#' \item{calculate_duration}{(numdays|dose_duration|qty/ndd)}
#' \item{missing_duration}{(ignore|mean) (individual|population|both)}
#' \item{clash_start}{(ignore|mean|shortest|longest|sum)}
#' \item{overlapping}{(allow|shift)}
#' \item{small_gaps}{(ignore|close) (15|30|60)}
#' 
decision_list2<-drugprepr::make_decisions('missing',
                                          'mean population',
                                          'missing',
                                          'mean population',
                                          'truncate 6',
                                          'qty / ndd',
                                          'mean population',
                                          'mean',
                                          'allow',
                                          'close 15')


##  RUN drugprepr 


for(i in 1:nrow(decision_list1)){
  
mined_opiate <- drugprepr::compute_ndd(opiate, as.character(decision_list1[i,1]), as.character(decision_list1[i,2]), mean)
names(mined_opiate)[2]<-"start_date" # the prescription date is captured as event_date in cprd 
mined_opiate$start_date<-as.Date(mined_opiate$start_date)
  
# Now we have done the pre-drugprep stages.
# Next is to do the full drugprep (decison 1-10)

cleaned_opiate <- drugprepr::drug_prep(data = mined_opiate,
                    plausible_values = min_max_extended,
                    decisions = decision_list2)


# Becuse, drugprep works on prodcode level, we may have multiple prescription with different prodcode
# since we are working with on/off drug, it might be fine to drop multiple prescription
# while preserving the exposure period.
# After doing the above merge the followup data with the processed drug exposure data

# For the time-to-event analysis, since we will have gaps between prescription do the following
# 1. If the stop date of one treatment interval is not equal to the start date of the next,
#    add a new interval to cover the time between them, with the treatment set to 0
# 2. If the stop date of the last treatment interval is less than the last followup date,
#    add a new interval from the end of treatment to the end of followup.
#

# For those with elligible fracture date, replace the stop date by the fracture date and
# remove information after that

cleaned_opiate<-cleaned_opiate[!is.na(cleaned_opiate$stop_date),]

cleaned_opiate <- cleaned_opiate %>%
  dplyr::ungroup() %>%
  dplyr::select(patid, start_date, stop_date, prodcode) %>%
  dplyr::mutate(
    start_date = data.table::as.IDate(start_date),
    stop_date = data.table::as.IDate(stop_date)
  ) %>%
  data.table::as.data.table() %>%
  intervalaverage::isolateoverlaps(
    .,
    interval_vars = c("start_date", "stop_date"),
    group_vars = c("patid"),
    interval_vars_out = c("rstart_date", "rstop_date") # to disambiguate
  ) %>%
  as.data.frame() %>%
  dplyr::group_by(patid, rstart_date) %>%
  dplyr::distinct(patid, rstart_date, .keep_all = TRUE) %>%
  dplyr::ungroup() %>%
  dplyr::select(-c(start_date, stop_date)) %>%
  dplyr::rename(start_date = rstart_date, stop_date = rstop_date) %>%
  dplyr::left_join(Follow_up_event, by = "patid") %>%
  dplyr::group_by(patid) %>%
  dplyr::mutate(
    tstart = as.numeric(start_date - indx_date),
    tstop = as.numeric(stop_date - indx_date),
    Lstop = as.numeric(last_fup_date - indx_date),
    Ftime = as.numeric(Fracture_date - indx_date)
  ) %>%
  dplyr::group_by(patid) %>%
  dplyr::mutate(
    gap = lead(tstart) - tstop,
    to_expand = ifelse(!is.na(gap) & gap > 1, 2, 1)
  ) %>%
  splitstackshape::expandRows(., "to_expand") %>%
  dplyr::group_by(patid, tstart) %>%
  dplyr::mutate(new_record = row_number()) %>%
  dplyr::group_by(patid) %>%
  dplyr::mutate(
    tstart = ifelse(new_record == 2, lag(tstop) + 1, tstart),
    tstop = ifelse(new_record == 2, lead(tstart) - 1, tstop),
    treat = ifelse(new_record == 2, 0, prodcode)
  ) %>%
  dplyr::group_by(patid) %>%
  dplyr::mutate(to_expand = ifelse(row_number() == n(), 2, 1)) %>%
  splitstackshape::expandRows(., "to_expand") %>%
  dplyr::group_by(patid, tstart) %>%
  dplyr::mutate(new_record = row_number()) %>%
  dplyr::group_by(patid) %>%
  dplyr::mutate(
    tstart = ifelse(new_record == 2, lag(tstop) + 1, tstart),
    tstop = ifelse(new_record == 2, Lstop, tstop),
    treat = ifelse(new_record == 2, 0, treat)
  ) %>%
  dplyr::select(-c(new_record)) %>%
  dplyr::mutate(tstop = case_when(
    !is.na(Ftime) & Elligible_fracture == TRUE & tstop >= Ftime ~ Ftime,
    TRUE ~ tstop
  )) %>%
  dplyr::filter(!((tstop - tstart) < 0)) %>%
  dplyr::group_by(patid) %>%
  dplyr::mutate(status = case_when(
    !is.na(Ftime) & Elligible_fracture == TRUE & row_number() == n() ~ 1,
    TRUE ~ 0
  ))%>%
  dplyr::mutate(treat1 = case_when(
    treat != 0 ~ 1,
    TRUE ~ treat
  )) %>%
  dplyr::mutate(tstop = case_when(
    tstart == tstop ~ tstop + 0.5,
    TRUE ~ tstop
  ))

write.csv(cleaned_opiate, file = here(paste0("Data/cleaned_opiate_FP_allow_",as.character(decision_list1[i,1]),"_",as.character(decision_list1[i,2]),".csv")))
}


## Fit cox regression model for each of the processed datasets 

fit <- coxph(Surv(tstart, tstop, status) ~ as.factor(treat1),
             data = cleaned_opiate)
summary(fit)[["conf.int"]]

## To get the person-years of follow up  
pfit <- pyears(Surv(tstart, tstop, status) ~ as.factor(treat1),
               data = cleaned_opiate)
summary(pfit)
